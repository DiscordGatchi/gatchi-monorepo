generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// GLOBAL

model User {
  id String @id // snowflake

  prints CardPrint[]

  printHistory PrintOwnerHistory[]

  guildMemberRefs GuildMemberRef[]
}

// EVERYTHING ANACHI

enum ModServerAction {
  BAN
  UNBAN
  KICK
  TIMEOUT
  UNTIMEOUT
  MUTE
  UNMUTE
  DEAFEN
  UNDEAFEN
  DISCONNECT
  WARNING
  FORGIVE
}

enum ModRoleType {
  TRIAL_MOD
  MOD
  ADMIN
  OWNER
}

enum ModChannelType {
  MESSAGE_LOGS
  SERVER_UPDATES_LOGS
  VC_UPDATES_LOGS
  MEMBER_UPDATES_LOGS
  ROLE_CHANGES_LOGS
  GREETING_LOGS
  JOIN_LEAVE_LOGS
  MOD_ACTION_LOGS
  TICKET_LOGS
  TICKET_REQUESTS
}

model GuildSettings {
  id String @id // SNOWFLAKE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Guild settings
  modRoles    ModRole[]
  modChannels ModChannel[]

  roleAssigners RoleAssigner[]
}

model RoleAssigner {
  id Int @id @default(autoincrement())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  guildId       String
  guildSettings GuildSettings @relation(fields: [guildId], references: [id])

  channelId String
  messageId String
}

model ModRole {
  id Int @id @default(autoincrement())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type   ModRoleType
  roleId String // SNOWFLAKE

  guildId       String // SNOWFLAKE
  guildSettings GuildSettings @relation(fields: [guildId], references: [id])
}

model ModChannel {
  id Int @id @default(autoincrement())

  type      ModChannelType
  channelId String // SNOWFLAKE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  guildId       String // SNOWFLAKE
  guildSettings GuildSettings @relation(fields: [guildId], references: [id])
}

model GuildMemberRef {
  userId String @id
  user   User   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lastActiveAt        DateTime? // for the last time a user was active
  lastActiveMessageId String? // SNOWFLAKE
  lastOffenseAt       DateTime? // for the last time a user had an offense

  name          String
  discriminator String

  joinedGuildAt   DateTime?
  joinedDiscordAt DateTime?

  previousInfo   GuildMemberInfoHistory[]
  offenseHistory GuildMemberOffenseHistory[] @relation("offender")

  // Moderator fields
  isModerator Boolean @default(false)
  isTrialing  Boolean @default(false)

  offensesGiven GuildMemberOffenseHistory[] @relation("moderator")

  createdTickets  Ticket[] @relation("creator")
  assignedTickets Ticket[] @relation("assignee")

  lastActionAt DateTime? // for the last time a moderator issued an action on another user
}

model GuildMemberInfoHistory {
  id Int @id @default(autoincrement())

  updatedAt DateTime @updatedAt

  name          String
  discriminator String

  memberRefId String
  memberRef   GuildMemberRef @relation(fields: [memberRefId], references: [userId])
}

model GuildMemberOffenseHistory {
  id Int @id @default(autoincrement())

  updatedAt DateTime @updatedAt

  action ModServerAction
  reason String

  forgiven Boolean @default(false)

  moderatorId String
  moderator   GuildMemberRef @relation("moderator", fields: [moderatorId], references: [userId])

  memberRefId String
  memberRef   GuildMemberRef @relation("offender", fields: [memberRefId], references: [userId])
}

model Ticket {
  id Int @id @default(autoincrement())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type   TicketType
  status TicketStatus

  title   String
  content String

  creatorId String
  creator   GuildMemberRef @relation("creator", fields: [creatorId], references: [userId])

  assigneeId String?
  assignee   GuildMemberRef? @relation("assignee", fields: [assigneeId], references: [userId])
}

enum TicketType {
  APPEAL
  REPORT
  SUGGESTION
  FEEDBACK
  OTHER
}

enum TicketStatus {
  OPEN
  CLAIMED
  CLOSED
  DISMISSED
  INVALID
}

// EVERYTHING KADO

enum DirtLevel {
  SHINY
  NORMAL
  DIRTY
}

model Collection {
  id Int @id @default(autoincrement())

  name String @unique

  cards Card[]
}

model Card {
  id Int @id @default(autoincrement())

  prints CardPrint[]

  name        String
  description String
  icon        String

  issues CardIssue[]

  // Must satisfy 0 <= float < 1, can be generated via Math.random()
  // Used for print number generation (`shuffeYates(issuePrints, seed)`)
  seed Float

  collectionId Int
  collection   Collection @relation(fields: [collectionId], references: [id])
}

model CardIssue {
  id Int @id @default(autoincrement())

  cardId Int
  card   Card @relation(fields: [cardId], references: [id])

  issueDate  DateTime @default(now())
  printCount Int
}

model CardPrint {
  printId Int

  cin String @unique

  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id])

  cardId Int
  card   Card @relation(fields: [cardId], references: [id])

  ownerHistory PrintOwnerHistory[]

  powerLevel Int
  dirtLevel  DirtLevel
}

enum PrintAttainmentType {
  ROLLED
  TRADED
  GIFTED
}

enum PrintDepartureType {
  TRADED
  GIFTED
  RELEASED
}

model PrintOwnerHistory {
  id Int @id @default(autoincrement())

  print   CardPrint @relation(fields: [printId], references: [cin])
  printId String

  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String

  attainedAt   DateTime
  attainedType PrintAttainmentType

  departedAt   DateTime?
  departedType PrintDepartureType?
}
